//#version 120

varying	vec3			vNormal;
varying vec3			vEyeVector;
varying vec2			vTexCoords;
varying vec3			vLight1Vector;
varying vec3			vCoords;
varying mat3			vTBN;

uniform float fPlanetRadius;
uniform float fAtmosRadius;

uniform sampler2D uCloudMap;
uniform sampler2D uDiffuseMap;



varying vec3 Point;
varying vec3 Eye;
varying vec3 Light;

//varying float cosPointEye;
varying float cosPointLight;

varying float   maxOccAngle; 
varying float   maxOccDistance;
varying float   minOccDistance;


varying vec3 Sample[4];
varying float LDist[4];

varying float Distance;


void main(void) {

    vec3 Illumination = 0.0;
    float Opacity = 0.0;
    float eyeDistance = 0.0;
    float Height = 0.0;
    float MaxDepth =  fPlanetRadius / fAtmosRadius; 
    float cosPointEye = dot( normalize(Point) , -normalize(Eye) );

    float rayDepth = 0.0;
    if (  cosPointEye < -maxOccAngle ) {
        // ground
        //rayDepth  = smoothstep( -1.0, -maxOccAngle, cosPointEye );
        //rayDepth = minOccDistance + ( rayDepth * maxOccDistance );
        
        //rayDepth = smoothstep( minOccDistance, maxOccDistance, rayDepth );
        //smoothstep( maxOccAngle,1.0 , 1.0 - cosPointEye );
        rayDepth =  1.0 - -cosPointEye;
        Opacity = rayDepth;
    } else {
        // atmosphere
        rayDepth = 1.0 - ( smoothstep( -maxOccAngle, 0.0 , cosPointEye) + maxOccAngle ) ; //(-2.0 * -cosPointEye)  ;
         ;  // smoothstep(0.0,maxOccAngle,cosPointEye);
        //smoothstep( 0.0, maxOccAngle ,cosPointEye  ); //smoothstep(0.0,maxOccAngle,cosPointEye);
        //rayDepth*= maxOccDistance;
        //gl_FragColor.b = 0.2;
        //rayDepth = smoothstep( -maxOccAngle,maxOccAngle,-cosPointEye);    
        //rayDepth *= 2.0;    
        //rayDepth = 1.0 - rayDepth;
        Opacity = rayDepth;
    }
    
    float fSamples = 1.0;
    int samples = int(fSamples);
  
    vec3 SampleOffset = -normalize(Eye) * (rayDepth / fSamples);    
    vec3 samplePoint = Point + (SampleOffset*0.5);

    float avg=0.0;
    float backscatter = 0.0;
    float atten=0.0;
    float occ=0.0;
    float height=0.0;

    //vec3 nEye = normalize(Eye);
    vec3 nLightMSample = normalize(Light-Eye);    
//    vec3 nLight = normalize(Light);
        
    for (int i=0;i<samples;i++) {
        vec3 nSample = normalize(samplePoint);
    
        float dotSampleLight = dot(
            nSample,
            nLightMSample
        );
        //float dotSampleEye = dot(
        //    nSample,            
        //    nEye
        //);

        //if (  dotSampleEye > maxOccAngle ) {
            // ground
            avg += dotSampleLight;
            atten += distance(samplePoint,Point);
            occ += smoothstep(-maxOccAngle,0.0,dotSampleLight);

        //} else {
            // atmosphere
            //avg += dotSampleLight ;
            //atten += distance(samplePoint,Point);
            //occ += smoothstep( -maxOccAngle,0.0,dotSampleLight);


        //}


       

        //backscatter +=  dot( normalize( Eye+samplePoint ) ,normalize(Light)  );

        samplePoint += SampleOffset;

    }
    avg/= fSamples;
    occ/= fSamples;
    atten /= fSamples;

    //atten = rayDepth;
    backscatter /= fSamples;
    backscatter = 0.5 + (backscatter*0.5);


gl_FragColor.rgb = vec3(0.0);

    Illumination += exp(vec3(0.25,0.5,1.0) *avg+atten ) - vec3(0.9999) ;    
    //Illumination += occ * Illumination * 0.5;

    float Alpha = occ*atten;
    float Intensity = length(Illumination) / 1.4142;

    gl_FragColor.rgb = Illumination;// / Intensity;    

    //gl_FragColor.rgb -= (1.0 - occ) * gl_FragColor.rgb; 
    //gl_FragColor.b = avg;
;//1.0 - exp( vec3(0.6,0.8,2.4) * avg * atten);
//    gl_FragColor.rgb += vec3(1.0,0.7,0.15) * (1.0 - clamp(atten,0.0,1.0) );
    //gl_FragColor.rgb = normalize(gl_FragColor.rgb);
//    gl_FragColor.r = atten;
//    gl_FragColor.g = occ;
    gl_FragColor.a = exp(rayDepth*occ)-1.0;;//clamp(Intensity,0.0,1.0)    * occ;//occ * atten; //pow(rayDepth,2.0) * (1.0-occ);



}

