//#version 120

varying	vec3			vNormal;
varying vec3			vEyeVector;
varying vec2			vTexCoords;
varying vec3			vLight1Vector;
varying vec3			vCoords;
varying mat3			vTBN;

uniform float fPlanetRadius;
uniform float fAtmosRadius;


bool IOsphereIntersect(vec3 vPos,vec3 vRay,float Radius,inout vec3 vIntersect,inout vec3 vExit,inout float Dist) {
	float Radius2= Radius*Radius;	
	float tca = dot(vPos,normalize(vRay));
	if (tca < 0.0 ) {
		return false;
	}
	//float d2 = length(ooposition - vPos ) - pow(tca,2.0);
	float d2 = length(vPos) - pow(tca,2.0);
	if (d2 > Radius2) { 
		return false;
	}


	float thc = sqrt( Radius2 - d2 );
	float t0 = tca - thc;
	float t1 = tca + thc;
	Dist = thc*2.0;
    Dist = length( t0 - t1 );
    float tnear;
    float tfar;
    if ( t0 > 0.0 ) {
        tnear = t0;	
        tfar = t1;

    } else {
        tnear = t1;
        tfar = t0;
    }
    vIntersect = vPos + tnear * vRay;
    vExit = vPos + tfar * vRay; 
	return true;	
}



varying vec3 Point;
varying vec3 Eye;
varying vec3 Light;

varying float cosPointEye;
varying float cosPointLight;
varying float maxOccAngle; 
varying float   maxOccDistance;
varying float   minOccDistance;

void main(void) {

    vec3 Near = Point;
    vec3 Far = Point;
    vec3 Mid = Point;
    vec3 SampleVec = vec3(0.0);

    float Illumination = 0.0;
    float Opacity = 0.0;
    float eyeDistance = 0.0;
    float Height = 0.0;

/*
float DensityScale = ( fAtmosRadius - fPlanetRadius   ) / fAtmosRadius ;
float MaxDepth =  fPlanetRadius / fAtmosRadius; 

    if ( maxOccAngle > cosPointEye ) {
        Far = Point - (normalize(Eye) * (1.0 -cosPointEye) );
        
        Mid = Point - ( normalize(Eye) * (1.0-cosPointEye)  * 0.5);
                   
        //Height =  smoothstep(0.0,maxOccAngle,  cosPointEye );
        Height = distance(Near,Far);
        Height = smoothstep(  MaxDepth, 1.0 - MaxDepth, Height ) * 3.14 * 2.0;
        //Height = smoothstep( 0.0 , 2.0* maxOccAngle , Height);
        //Height = dot(normalize(Mid),normalize(Light));
        
        //eyeDistance = smoothstep( maxOccAngle*(fPlanetRadius/fAtmosRadius), maxOccAngle, cosPointEye );
// exp( length(Near-Far) ) / 12.5;
        eyeDistance = distance(Near,Far);

        //Height = ( length( Mid ) - (fPlanetRadius / fAtmosRadius ) );
        float Depth = 1.0 - smoothstep( fPlanetRadius/fAtmosRadius , 1.0, Height );
        Illumination = smoothstep( -maxOccAngle, 0.0, cosPointLight);
        Illumination += smoothstep( -maxOccAngle, 0.0, 
                                    dot(normalize(Light),normalize(Far))
                        );
        Illumination *= 0.5;
        gl_FragColor.g = Height;


    } else {
        gl_FragColor.g = 0.15;
        Far = Point - (normalize(Eye) *  (1.0 - cosPointEye)  );
        Far += (normalize(Eye) * (1.0 - cosPointEye) * (1.0 - MaxDepth) );
        eyeDistance =  length(Near-Far);
        Mid = Point - (normalize(Eye) *  (1.0 - cosPointEye) * (eyeDistance/2.0) );

        //Height = length(Far +normalize(Eye)) - MaxDepth;

        Height = distance(Near,Far);
        Height = smoothstep( DensityScale, MaxDepth, Height );
        

        Illumination = smoothstep( -maxOccAngle, 0.0, cosPointLight);
        Illumination += smoothstep( -maxOccAngle, 0.0, 
                                    dot(normalize(Light),normalize(Far))
                        );
        Illumination *= 0.5;
        gl_FragColor.r = Height;
    }
*/



    if (  cosPointEye > maxOccAngle ) {
        // ground
        //Opacity  = ( exp( 1.0 - smoothstep(  maxOccAngle, 1.0 , cosPointEye ) ) - 1.0 ) / 1.71828;
        Opacity  =1.0 - smoothstep(  maxOccAngle, 1.0 , cosPointEye );
        Opacity = pow(Opacity,5.0);
 
    } else {
        // atmosphere
        //gl_FragColor.g = (exp(smoothstep(  0.0 , maxOccAngle, cosPointEye ) ) -1.0 )  / 1.71828 ;
        //gl_FragColor.g = 1.0 - clamp(gl_FragColor.g , 0.0,1.0);
        Opacity = smoothstep(0.0,maxOccAngle,cosPointEye);        
        Opacity = pow(Opacity,5.0);
    }

    vec3 vIllum = gl_LightSource[1].diffuse.rgb;

    float fOcclude = smoothstep( -maxOccAngle, 0.0, cosPointLight);
 
    vIllum *=  mix( vec3(0.8,0.42,0.1),vec3(0.1,0.25,1.0)  , fOcclude );
    vIllum += vec3(0.5) * Opacity;
    vIllum += gl_LightSource[1].ambient.rgb;
    //vIllum = mix( gl_LightSource[1].ambient.rgb , vIllum, fOcclude ); 
    gl_FragColor.rgb = vIllum;    
    //gl_FragColor.rgb = clamp( vIllum / Opacity, 0.0,1.0);
    //gl_FragColor.r = smoothstep( -maxOccAngle, 0.0, cosPointLight);  

    Opacity *=   fOcclude;

    gl_FragColor.a = Opacity;
}

