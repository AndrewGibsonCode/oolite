//#version 120

varying	vec3			vNormal;
varying vec3			vEyeVector;
varying vec2			vTexCoords;
varying vec3			vLight1Vector;
varying vec3			vCoords;
varying mat3			vTBN;

uniform float fPlanetRadius;
uniform float fAtmosRadius;


bool IOsphereIntersect(vec3 vPos,vec3 vRay,float Radius,inout vec3 vIntersect,inout vec3 vExit,inout float Dist) {
	float Radius2= Radius*Radius;	
	float tca = dot(vPos,normalize(vRay));
	if (tca < 0.0 ) {
		return false;
	}
	//float d2 = length(ooposition - vPos ) - pow(tca,2.0);
	float d2 = length(vPos) - pow(tca,2.0);
	if (d2 > Radius2) { 
		return false;
	}


	float thc = sqrt( Radius2 - d2 );
	float t0 = tca - thc;
	float t1 = tca + thc;
	Dist = thc*2.0;
    Dist = length( t0 - t1 );
    float tnear;
    float tfar;
    if ( t0 > 0.0 ) {
        tnear = t0;	
        tfar = t1;

    } else {
        tnear = t1;
        tfar = t0;
    }
    vIntersect = vPos + tnear * vRay;
    vExit = vPos + tfar * vRay; 
	return true;	
}


varying float cosPointEye;
varying float cosPointLight;
varying float maxOccAngle; 

void main(void) {
    gl_FragColor.g = step( maxOccAngle , cosPointEye );// vCoords;
    gl_FragColor.r = step( -maxOccAngle, cosPointLight);   
     //gl_FragColor.rgb = vCoords;
    gl_FragColor.a = 1.0;
}

void  FOOmain(void) {
    vec3 vertexEye = normalize(vNormal) ;
	float fObjAtmosDepth =  fPlanetRadius / fAtmosRadius ;
    float fObjAtmosHeight = ( fAtmosRadius - fPlanetRadius ) / fAtmosRadius;
	//float fObjAtmosMaxDist = sqrt( 1.0 - pow( ( fAtmosRadius-fPlanetRadius 
    float dist = 0.0;
    vec3 NearHit = vec3(0.0);
    vec3 FarHit  = vec3(0.0);
    gl_FragColor.rgb = vec3(1.0,0.0,1.0);

    vec3 PlanetNear = vec3(0.0);
    vec3 PlanetFar = vec3(0.0);
    vec3 AtmosNear = vec3(0.0);
    vec3 AtmosFar  = vec3(0.0);

    if( IOsphereIntersect( vertexEye, vEyeVector   , 0.999 ,
                             AtmosNear , AtmosFar , dist ) == true ) {
        gl_FragColor.b = dist;
        // eye light angle
        //_FragColor.r = dot(normalize(vEyeVector),normalize(vLight1Vector+vEyeVector));
        NearHit = AtmosNear;
        FarHit = AtmosFar;    
        gl_FragColor.a = 0.5;
    }

    if( IOsphereIntersect( vertexEye, vEyeVector , fObjAtmosDepth, 
                            PlanetNear , PlanetFar , dist ) == true ) {

        //gl_FragColor.b = dist;
        //gl_FragColor.g = 0.5;
        //gl_FragColor.a = 0.8;
        FarHit = PlanetNear;
    } 
    dist = distance(NearHit,FarHit);

//    vec3 MidSample = gl_NormalScale * (vertexEye  + FarHit ) *0.5 ;
    float fSamples = 5.0;
    int   nSamples = 5;
        
    vec3 SampleVec = gl_NormalScale * (-normalize(vEyeVector) * dist ) / fSamples;

    vec3 MidSample = gl_NormalScale * (vertexEye + ( dist * 0.5 * normalize(vEyeVector) ) );

    float CollectHeight = 0.0;
    vec3 SamplePos = vertexEye;
    SamplePos += SampleVec*0.5;
    for (int i=0; i<nSamples; i++) {
        CollectHeight +=  length(SamplePos) - fObjAtmosDepth;
        SamplePos += SampleVec;
    }
    //CollectHeight /= fSamples;

    // gross scale of effect - distance of travel through medium
    float EyeDistance  =  dist  * gl_NormalScale; //smoothstep( fPlanetRadius/fAtmosRadius, 1.0 , length(MidSample) );

    float Height =  1.0 - length(MidSample) ; 
    gl_FragColor.b = EyeDistance ; // abs(CollectHeight)/ fSamples;

    // stable - but is in wrong space compared to MidSample
    gl_FragColor.r =  dot(normalize(vNormal),-normalize(gl_LightSource[1].position.xyz ));

    //gl_FragColor.rgb = SampleVec;

    gl_FragColor.a = 1.0;
     // gl_FragColor.r = length(MidSample) / fAtmosRadius;
  //  gl_FragColor.b = length(NearHit - FarHit) / fAtmosRadius;

}



/*
void NOTmain(void) {
	vec3 vLightCol = gl_LightSource[1].diffuse.rgb;
	float fObjAtmosDepth =  fPlanetRadius / fAtmosRadius ;
    float fObjAtmosHeight = ( fAtmosRadius - fPlanetRadius ) / fAtmosRadius;
	//float fObjAtmosMaxDist = sqrt( 1.0 - pow( ( fAtmosRadius-fPlanetRadius ) / fAtmosRadius, 2.0 )  ) ;
	//fObjAtmosMaxDist /= 3.14;
    float fObjAtmosMaxDist = sqrt( pow(fAtmosRadius,2.0) - pow(fPlanetRadius,2.0) ) * 2.0;

    vec3 AtmosHit;
	vec3 AtmosExitHit;
    vec3 SurfaceHit;
    vec3 SurfaceExitHit;
	float AtmosDist = 0.0;
	float SurfaceDist = 0.0;

    vec4 outColor = vec4(0.0);

	float EyeDist;
    vec3 MidSample;
    float height;
    outColor.rgb = vec3(0.0);        
    vec3 FarHit;
	if ( 
		IOsphereIntersect(normalize(eyeVector) + vVertexObj, normalize(eyeVector), 1.0 ,AtmosHit,AtmosExitHit,AtmosDist) == true) {
 		FarHit = AtmosExitHit;
        EyeDist = AtmosDist / ( fObjAtmosMaxDist / fAtmosRadius );
	    outColor.b = 1.0;
    }

	if (IOsphereIntersect(normalize(eyeVector) + vVertexObj,normalize(eyeVector), fObjAtmosDepth ,SurfaceHit,SurfaceExitHit,SurfaceDist) == true) {
	    FarHit = SurfaceHit;
    	EyeDist = ( AtmosDist - SurfaceDist );
        EyeDist /=  (fObjAtmosMaxDist / fAtmosRadius);
        outColor.b = 0.0;
        outColor.g = 0.5;
    }  


    //MidSample = AtmosHit + ( normalize(eyeVector) * EyeDist * 0.5);
    MidSample = vVertexObj + (normalize(eyeVector) * 0.5 * EyeDist  );    
    height =    length(MidSample);
    float depth = ( height - fObjAtmosDepth ) * (1.0 -  fObjAtmosHeight);

    //  outColor.rgb = MidSample;
    // outColor.rgb = eyeVector/fAtmosRadius;

	//float fScatter = (AtmosDist - SurfaceDist ) / fObjAtmosMaxDist;
	float fScatter =  EyeDist;
	float fOpacity = height;
	


	vec3 Light1Obj = (gl_LightSource[1].position.xyz -ooposition ) ;
	float Occlude = dot( normalize(Light1Obj),normalize(MidSample)) ; //MidSample or vVertexOb;
    Occlude = 0.25 + smoothstep( -0.1, 0.1 ,Occlude) *0.5 ;

	float Directional = dot(normalize(Light1Obj),normalize(MidSample));
	Directional = smoothstep( 0.0, 1.0  , -Directional );
    //outColor.r = smoothstep(-1.0,1.0 , Directional) ;
     
    float finalOpacity = EyeDist * Occlude;
    //finalOpacity += length( gl_LightSource[1].ambient );

    //outColor.b = fOpacity;
    //outColor.g = Occlude;
    //outColor.r = Directional;

    //outColor.rgb = ( height - fObjAtmosDepth ) * (1.0 -  fObjAtmosHeight);
    
    //outColor.rgb /= finalOpacity;
    //outColor.rgb = clamp( outColor.rgb , 0.0, 1.0 );
    
    //outColor.a = finalOpacity;
    outColor.a = 1.0 ; // ;
//
	vec3 vRayleigh = 2.0 * Scattering.rgb * fScatter  *  smoothstep(-0.25,.25, Occlude);
	vec3 ivRayleigh = 2.0 * Scattering.rgb * fScatter  *  smoothstep(.25,-0.25, Occlude);
	outColor.rgb += vRayleigh;
	vLightCol -= ivRayleigh;
	outColor.rgb += (vLightCol * fScatter * Directional );


	//vColor.a = fScatter * Directional;
	//vColor.a = fOpacity * Directional;
    outColor.r = 1.0;
	
    // Blend based on degree of scattered light AND the occlusion 
    outColor.a = fOpacity;
    outColor.a *= Directional;
	//outColor.a *= 1.0 * smoothstep(-0.25,0.05, Occlude);

 //
    

// SAMPLING
//
	int iSamples = 5;
	float fSamples = 5.0;

	float depthScale = fOuterRadius - fInnerRadius;
	float EyeDist;
	if ( SurfaceHit == true ) {
		EyeDist = ( AtmosDist - SurfaceDist ) / 2.0;
		//EyeDist = distance(vVertexObj,Hit);
	} else {
		EyeDist = AtmosDist; 
	}
	
	vec3 dOffset = (-normalize(eyeVector)  * EyeDist ) / fSamples;

	vec3 samplePoint = vVertexObj;
	float fOcclude = 1.0;
	vec3 PlanetHit;
	float PlanetDist = 1.0;
	vec3 Light1Obj = (gl_LightSource[1].position.xyz -ooposition ) ;
	float fDensity = 0.0;
// Occlusion samples

	vec3 vScatter = vec3(0.0);

for (int i=0;i < iSamples;i++) { 

	samplePoint += dOffset;
	fDensity +=  pow( 1 -smoothstep( fInnerRadius, fOuterRadius , length(samplePoint)*fOuterRadius  ), 2.0 );
	float Occlude = dot(normalize(Light1Obj),samplePoint);
	fOcclude -= smoothstep(-0.20,0.5, Occlude)/fSamples;
	//

	vec3 vRayleigh = (  Scattering * fDensity   *  smoothstep(0,1, Occlude)  )/ fSamples;
	vec3 ivRayleigh = (  Scattering * fDensity   *  smoothstep(1,0, Occlude)  )/ fSamples;
	vScatter += vRayleigh ;	
	vLightCol -= ivRayleigh;
	// Mie 
	vScatter += ( 0.1 * vLightCol * fDensity ) / fSamples;	
	//vScatter = vLightCol;	
}	

	fDensity /= fSamples;
	outColor.a = fDensity * (1.0-fOcclude);
	//vColor.a = 1.0;
	outColor.rgb = vScatter.rgb;
	outColor.rgb /= vColor.a;


	gl_FragColor = outColor;	
}

*/


